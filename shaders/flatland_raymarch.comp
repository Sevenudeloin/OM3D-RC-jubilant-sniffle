#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, r16f) uniform image2D jfa_dist_image;
layout(binding = 1, rgba8) uniform image2D draw_image;
layout(binding = 2) uniform sampler2D prev_image;
layout(binding = 3, rgba8) uniform image2D output_scene_image;

uniform vec2 resolution;

uniform float base;
uniform float cascade_index;
uniform float cascade_count;
uniform bool last_index = false; // last cascade to be drawn

#define MAX_STEPS 32

#define TAU 6.2831855
#define SRGB 2.2

#define INTERP_CLOSE 0.5625
#define INTERP_DIAG 0.1875
#define INTERP_FAR 0.0625

bool out_of_bounds( in vec2 uv ) {
    return uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0;
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    ivec2 texture_size = imageSize(jfa_dist_image);
    if (pixel_coords.x >= texture_size.x || pixel_coords.y >= texture_size.y) {
        return;
    }

    vec2 uv = pixel_coords / vec2(texture_size);

    //

    bool is_first_level = (cascade_index == 0.0);

    float ray_count = pow(base, cascade_index + 1.0);
    float sqrt_base = sqrt(base);

    float angle_step_size = TAU / float(ray_count);

    float spacing = pow(sqrt_base, cascade_index);
    vec2 size = floor(resolution / spacing);

    vec2 probe_relative_pos = mod(vec2(pixel_coords), size);
    vec2 ray_pos = floor(vec2(pixel_coords) / size);

    float base_index = float(base) * (ray_pos.x + (spacing * ray_pos.y));

    vec2 probe_center = (probe_relative_pos + 0.5) * spacing;
    vec2 normalized_probe_center = probe_center / resolution;

    float modifier_hack = base < 16.0 ? 1.0 : 4.0; // really useful but ugly and dont understand yet
    float min_resolution = min(resolution.x, resolution.y);
    float interval_start = is_first_level ? 0.0 : (modifier_hack * pow(base, cascade_index - 1.0)) / min_resolution;
    float interval_length = (modifier_hack * pow(base, cascade_index)) / min_resolution;

    vec2 resolution_scale = min_resolution / resolution;
    float min_step_size = min(1.0 / resolution.x, 1.0 / resolution.y) * 0.5;

    // Raymarch
    vec4 radiance = vec4(0.0);

    // Loop only through base rays
    for (int i = 0; i < int(base); i++) {
        float index = base_index + float(i);
        float angle = angle_step_size * (index + 0.5); // (for 4 dirs, "+" pattern, +0.5 -> "x" pattern)
        vec2 ray_dir_uv = vec2(cos(angle), sin(angle));

        // vec2 sample_uv = normalized_probe_center + ray_dir_uv * interval_start * resolution_scale;
        float traveled = interval_start;

        vec4 radiance_delta = vec4(0.0);

        for (int step_i = 1; step_i < MAX_STEPS; step_i++) {
            vec2 sample_uv = normalized_probe_center + (ray_dir_uv * traveled) * resolution_scale;

            if (out_of_bounds(sample_uv)) {
                break;
            }

            vec4 light_sample = imageLoad(draw_image, ivec2(sample_uv * texture_size));
            if (light_sample.a > 0.1) {
            // if (dist <= min_step_size) { // THE PROBLEM
                radiance_delta += vec4(pow(light_sample.rgb, vec3(SRGB)), light_sample.a);
                break;
            }

            float dist = imageLoad(jfa_dist_image, ivec2(sample_uv * texture_size)).r;
            traveled += dist;
            if (traveled >= interval_length) {
                break;
            }
        }

        // Merge with upper cascade
        if (cascade_index < (cascade_count - 1.0) && radiance_delta.a == 0.0) {
            float upper_spacing = pow(sqrt_base, cascade_index + 1.0);
            vec2 upper_size = floor(resolution / upper_spacing);
            vec2 upper_position = vec2(
                mod(index, upper_spacing), floor(index / upper_spacing)
            ) * upper_size;

            vec2 offset = (probe_relative_pos + 0.5) / sqrt_base;
            offset = clamp(offset, vec2(0.5), upper_size - 0.5); // to avoid light leaking from one side to the other

            vec4 upper_sample = texture(prev_image, (upper_position + offset) / resolution);

            radiance_delta += upper_sample;
        }

        radiance += radiance_delta;
    }

    vec3 res = radiance.rgb / float(base);

    imageStore(output_scene_image, pixel_coords, vec4(
        last_index ? pow(res, vec3(1.0 / SRGB)) : res, 1.0 // only sRGB correct when writing if last cascade to be drawn
    ));
}