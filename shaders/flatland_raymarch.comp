#version 450

layout(local_size_x = 16, local_size_y = 16) in;

layout(binding = 0, r16f) uniform image2D jfa_dist_image;
layout(binding = 1, rgba8) uniform image2D draw_image;
layout(binding = 2, rgba8) uniform image2D prev_image;
layout(binding = 3, rgba8) uniform image2D output_scene_image;

uniform vec2 resolution;

uniform uint base_ray_count;
uniform uint ray_count;
uniform uint max_steps = 32;

#define TAU 6.2831855
#define EPS3 0.001
#define EPS5 0.00001
#define SRGB 2.2

bool out_of_bounds( in vec2 uv ) {
    return uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0;
}

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    ivec2 texture_size = imageSize(jfa_dist_image);
    if (pixel_coords.x >= texture_size.x || pixel_coords.y >= texture_size.y) {
        return;
    }

    vec2 uv = pixel_coords / vec2(texture_size);

    //

    // vec4 light = imageLoad(draw_image, pixel_coords);
    // if (light.a > 0.1) {
    //     imageStore(scene_image, pixel_coords, light);
    //     return;
    // }

    bool is_first_level = (ray_count == base_ray_count);

    float angle_step_size = TAU / float(ray_count);

    float interval_partial = 0.125; // play with
    float interval_start = is_first_level ? 0.0 : interval_partial;
    float interval_end = is_first_level ? interval_partial : sqrt(2.0); // sqrt(2) is longest possible in uv space

    vec2 resolution_scale = min(resolution.x, resolution.y) / resolution;
    float min_step_size = min(1.0 / resolution.x, 1.0 / resolution.y) * 0.5;

    // Probes stuff
    float sqrt_base_ray_count = sqrt(float(base_ray_count));
    float spacing = is_first_level ? 1.0 : sqrt_base_ray_count;
    vec2 size = floor(resolution / spacing);

    vec2 probe_relative_pos = mod(vec2(pixel_coords), size);
    vec2 ray_pos = floor(vec2(pixel_coords) / size);

    float base_index = float(base_ray_count) * (ray_pos.x + (spacing * ray_pos.y));

    vec2 probe_center = (probe_relative_pos + 0.5) * spacing;
    vec2 normalized_probe_center = probe_center / resolution;

    // Raymarch
    vec4 radiance = vec4(0.0);

    for (int i = 0; i < base_ray_count; i++) {
        float index = base_index + float(i);
        float angle = angle_step_size * (index + 0.5); // + 0.5 to avoid vertical angles
        vec2 ray_dir_uv = vec2(cos(angle), sin(angle)); // -sin ?

        vec2 sample_uv = normalized_probe_center + ray_dir_uv * interval_start * resolution_scale;

        float traveled = interval_start;

        for (int step_i = 1; step_i < max_steps; step_i++) {
            float dist = imageLoad(jfa_dist_image, ivec2(sample_uv * texture_size)).r;
            sample_uv += ray_dir_uv * dist * resolution_scale;

            if (out_of_bounds(sample_uv)) {
                break;
            }

            if (dist <= min_step_size) {
                vec4 light_sample = imageLoad(draw_image, ivec2(sample_uv * texture_size));
                radiance += vec4(pow(light_sample.rgb, vec3(SRGB)), 1.0);
                break;
            }

            traveled += dist;
            if (traveled >= interval_end) {
                break;
            }
        }

        if (is_first_level && radiance.a == 0.0) {
            // ??? UNDERSTAND TODO
            float upper_spacing = sqrt_base_ray_count;
            vec2 upper_size = floor(resolution / upper_spacing);
            vec2 upper_position = vec2(mod(index, sqrt_base_ray_count), floor(index / upper_spacing)) * upper_size;

            vec2 offset = (probe_relative_pos + 0.5) / upper_spacing;

            vec4 upper_sample = imageLoad(prev_image, ivec2(upper_position + offset));

            radiance += vec4(pow(upper_sample.rgb, vec3(SRGB)), upper_sample.a);
        }
    }

    vec3 res = radiance.rgb / float(base_ray_count);

    imageStore(output_scene_image, pixel_coords, vec4(pow(res, vec3(1.0 / SRGB)), 1.0));
}